# Text

## 摘要

随着宽带技术以及物联网技术的发展，现在家庭中的智能设备越来越多，无线路由器、网络存储等设备愈加频繁的出现在我们的生活当中。很多这样的设备，其操作系统都是基于一套名为 OpenWrt 的基于 Linux 的嵌入式系统定制而来。该系统拥有开放源代码、兼容平台广泛、高度灵活可定制化等特点，受到很多厂商欢迎，但其构建过程较为繁琐，尤其对于产品研发团队内的部分非技术职位人员来说门槛过高，他们构建用于评估、测试等需求用的环境时会有诸多不便。

本文描述一套用于实现自动构建 OpenWrt 环境的工具，其功能包括自动更新、自动构建 OpenWrt 环境，并可通过基于 Web 的图形化界面对定制过程进行定制，以求降低构建评估测试环境时的繁琐程度。在介绍容器、Web 服务、虚拟化和版本控制工具等相关技术的基础上，探讨如何利用这些技术达到上述目的，并给出综合这些技术后的系统整体解决方案。

关键词：自动构建、容器、Web 服务

## 1 绪论

### 1.1 研究背景和意义

随着宽带技术以及物联网技术的发展，现在家庭中的智能设备越来越多，不仅是很多电视、冰箱之类的白色家电都更多的加入了与网络连接的功能，更多样的工具比如扫地机器人、智能传感器等智能家居设备也越来越频繁的出现在我们的生活中。

很多这样的设备，其操作系统都是从一套名为 OpenWrt 的，基于 Linux 的嵌入式系统定制而来。该系统由包括 Linux 内核、opkg 包管理器、LuCI 管理界面、Busybox 等系统软件、以及一系列应用软件组合而成，兼容包括 Atheros、Qualcomm、MediaTek、BroadCom 等在内的绝大多数常见 SoC。其功能十分强大，且可以根据需求自由裁剪系统模块或增加特定功能；源代码完全开放，授权方式灵活，很多新的智能产品如小米、TP-Link、斐讯、水星等厂商的家庭用无线路由器，使用的都是基于 OpenWrt 深度定制并添加部分私有功能 / 驱动程序的操作系统。

OpenWrt 以上述一系列特点受到很多厂商青睐，使用 OpenWrt 开发智能设备使用的操作系统可以极大加快开发进度。但是产品研发的过程中涉及到一系列不同的参与者，对于部分不了解技术的团队成员来说需要降低他们实际参与开发活动的难度。

本文侧重于解决在基于 OpenWrt 进行项目开发时的一大难点：整体系统的构建。对于一个典型的 OpenWrt 项目，一般由 OpenWrt 原生组件（Linux 内核、LuCI 管理界面等）以及厂商编写的第三方软件（如智能流控、手机控制等）组合而成。测试人员进行测试时需要将需测试的组件或系统模块等的代码更新，然后再构建整个系统，构建完成之后将系统通过 TFTP 等方式烧写至测试用的设备中再进行后续的测试。而其中更新代码、构建整体系统这部分工作较为复杂，对于产品、测试人员来说不够友好。此外，构建环境本身的搭建也同样十分复杂，且构建环境对不同的目标平台无法实现隔离，非常不易于管理和维护。

### 1.2 项目研究目标

本文针对 1.1 节中提出的一系列问题，设计了一套构建工具。这套工具可以让用户以图形化的方式完成整个构建流程，使得用户可以非常轻松的完成上述组件更新以及系统构建的工作，提升工作效率；针对构建环境的运维问题，利用容器等技术对不同的构建环境进行隔离，区分管理。两者结合，使得项目开发综合效率得到显著提升。

### 1.3 本文工作和论文结构

本文主要介绍了这套自动构建系统的开发背景，以及设计和实现的工作，重点探讨了实际设计上的一些问题。

第一章讨论了本系统实现的背景以及期望达到的目标。

第二章介绍了本套系统设计上使用的一系列相关技术，包括 OpenWrt 嵌入式系统、OpenWrt 原构建系统的基础 Kbuild / Kconfig、管理构建环境时使用的 Docker 容器、搭建测试环境时使用的虚拟化相关技术、管理 OpenWrt 代码库以及厂商自有软件仓库使用的版本控制工具 Git，以及这套自动构建工具使用的 Web 后端框架 Django 以及前端框架 Bootstrap。

第三章介绍了本套系统的需求分析，包括可行性、功能性、可用性、安全性、性能等需求。

第四章介绍了整套系统的总体设计方案，包括整套系统的总体架构设计、对 OpenWrt 构建过程中一系列实体的抽象，以及完成构建工作所需的所有步骤。

第五章描述了第四章中所述所有设计的具体实现。

第六章首先介绍了开发过程中使用的工具以及环境，然后提出一些测试用例并展示了测试结果，对结果进行分析和说明。

第七章总结了本系统的功能点，介绍了已经完成的工作并列出了其中不足之处，并对下一步的工作进行介绍。

## 2 相关理论与技术

本章对论文研究中设计的相关理论和技术进行阐述，这些技术包括 OpenWrt 自身、OpenWrt 的原始构建工具集、基于 Docker 的容器技术、虚拟化相关的技术、用于版本控制的 Git、用于呈现用户界面的 Django 和 Bootstrap 框架等。

### 2.1 OpenWrt / LEDE

OpenWrt 是一款针对嵌入式系统设计的基于 Linux 的开源项目，主要被设计用于路由器等网络设备。其主要包括的组件有 Linux 内核、uClibC / musl C 标准库、BusyBox 工具集、opkg 包管理器、LuCI 界面等。OpenWrt 的所有基础组件都针对嵌入式的应用环境进行裁剪以及优化，因此可以运行在很多只有 32MB 内存、4MB Flash 空间的家用路由器上。

OpenWrt 支持超过 50 种不同的硬件体系结构，包括 MIPS、ARM、x86/64 等。市面上最常见的家用路由器一般采用来自 QualComm（Atheros）、BroadCom、MediaTek（RaLink）等公司的基于 MIPS 指令集的方案，这些公司的部分产品也有基于 ARM 指令集的。x86/64 方案则常见于网吧、中小型企业的路由设备中。

OpenWrt 包含强大的路由功能支持：硬件方面，除去上面提到的硬件体系结构的广泛支持外，也支持绝大多数厂商的有线、无线局域网硬件方案，以及常见的 LTE 移动网络方案；支持包括以太网、DSL、ISDN 等的一系列规范；支持 IPv4 和 IPv6；支持动态路由、VPN、QoS、防火墙、NAT、负载均衡、链路叠加等常见路由功能；支持包括 Mesh、WDS 等特性的无线网络功能。

除此之外，OpenWrt 还能通过 opkg 添加其他被 Linux 操作系统直接支持的硬件的支持；包括但不限于打印机、监控摄像头、声卡、外置存储设备等，并可以安装 Samba、PulseAudio、p910nd 等 Linux 上使用的应用软件。这使得 OpenWrt 除了作为路由器使用的操作系统之外，也非常适合其他的嵌入式设备，如网络存储、打印服务器、智能监控摄像头、智能音响等。

OpenWrt 与其他常见的针对家用路由器设计的嵌入式操作系统，如 DD-WRT 等的区别主要在于以下两点：

* OpenWrt 包含一个可以写入的根文件系统。OpenWrt 使用只读和压缩的 squashfs 提供根文件系统，并利用 overlayfs，采取 CoW（写时复制）的方式在只读的根文件系统上叠加一个 F2FS 文件系统。
* OpenWrt 利用包管理器 opkg 管理软件包。OpenWrt 官方提供的软件源中包含超过 3500 个不同的软件包，这使用户可以自由安装卸载软件，对自己的设备进行定制。

LEDE 是 Linux Embedded Development Environment 的缩写。它是 OpenWrt 的一个分支，采取比 OpenWrt 更加激进的开发流程。2016 年 5 月 LEDE 项目从 OpenWrt 拆分出来进行独立开发，之后 OpenWrt 几乎停止了迭代。月一年版之后的 2018 年 1 月，LEDE 与 OpenWrt 项目宣布合并，原 OpenWrt 项目被归档不再开发，LEDE 更名为 OpenWrt，取代原来的 OpenWrt。

### 2.2 OpenWrt BuildRoot、Kbuild 与 Kconfig

一般来说嵌入式设备会使用与其构建环境不同的体系结构，比如 OpenWrt 一般在 x86/64 设备上进行构建，构建后运行在 MIPS / ARM 设备上，这种构建方式被称为交叉编译。OpenWrt 自身的开发环境与构建系统统称为 OpenWrt BuildRoot，这套系统解决了 OpenWrt 构建过程中的一系列问题，如交叉编译所需工具链的集成、应用软件的交叉编译、CMake 等工具的集成、对不同设备映像的封装等。

OpenWrt 构建工具使用 Kconfig 配置构建过程中的可选项，如目标平台和软件包等。Kbuild 是 Linux 内核使用的构建工具集，Kbuild 在 GNU Make 的基础上对其 Makefile 进行了功能扩充，使得内核编译过程可以更加高效的完成；Kconfig 则是 Kbuild 使用的配置文件，用于定制 Kbuild 使用的一系列选项。

### 2.3 虚拟化

虚拟化技术是一种资源管理的技术，指将计算机中的资源进行抽象后拆分并重新组合为一个或多个资源组，使用户更好的使用这些计算资源的技术。

虚拟化技术覆盖的层次非常广泛，一般分为五个等级：

![](https://upload.wikimedia.org/wikipedia/commons/3/3a/VT5levels.JPG)

我们这里介绍其中两个等级。

#### 2.3.1 硬件虚拟化

硬件虚拟化指的就是将物理计算机中的资源进行拆分并重新组合为一些虚拟的计算机，这些虚拟计算机拥有与真实计算机类似的功能，并共享物理计算机所有的资源。这里的物理计算机称为宿主机（Host），其上运行的虚拟计算机称为客户机（Guest）。宿主机上运行的用于拆分、重组计算资源的软件被称为虚拟机管理器（Hypervisor）。

硬件虚拟化包括以下两种类别：

1. 全虚拟化（Full Virtualization）：用软件的方式完全模拟一个运行环境。这种方式运行的 Hypervisor 会提供完整的硬件特征，包括完整的体系结构、IO 操作、中断与内存管理等。在这样的环境中运行的代码不需进行任何修改。
2. 半虚拟化（Paravirtualization）：利用宿主机提供的 API 接口模拟运行环境，其上运行的代码需要针对宿主机平台特别定制，通常效率比全虚拟化要高，但是虚拟机的体系结构只能与宿主机保持一致。

很多现代 CPU 都会提供特殊的指令以便加速虚拟化过程，比如 Intel 的 VT-x 和 AMD 的 AMD-V；新一些的 CPU 还会提供对外部设备进行虚拟化的功能，比如 Intel 的 VT-d，利用这些功能可以使虚拟机直接控制宿主机上的部分硬件设备（如显卡、存储控制器、网络控制器等），极大提升硬件虚拟化的效率。现代操作系统均提供利用这些特性进行半虚拟化的支持，如 Windows 的 Hyper-V、Linux 的 KVM 等。一些第三方服务商，如 VMWare，提供的产品也支持利用这些虚拟化特性提高效率。

#### 2.3.2 操作系统级虚拟化

操作系统级虚拟化一般也被称为容器化，是指在操作系统的层面对不同的用户空间进行隔离的技术。被分离的用户空间一般被称为容器。容器中运行的代码只能操作对应容器被分配的资源配额，并且不同的容器之间互相完全不可见。

操作系统级虚拟化与硬件虚拟化相比，其优势在于可以减少在虚拟机上启动操作系统带来的资源消耗。容器内的应用程序直接使用宿主操作系统提供的系统调用，而不需要在虚拟机中启动新的操作系统，并由虚拟机上的操作系统提供用于与虚拟化的硬件进行交互的系统调用，如此可以极大降低启动时间和资源占用。而这也同样导致容器内的操作系统必须与宿主机保持一致，不能像硬件虚拟化那样，在 Linux 宿主机上运行 Windows 虚拟机。

在传统的类 Unix 操作系统中，通过 chroot 的方式可以实现对根文件系统的隔离。而在更新一些版本的 Linux 中，通过 cgroup（Control Group，控制组）和 namespace（命名空间）的方式可以实现对 CPU 核心、内存空间、网络、用户、进程等绝大多数系统资源的隔离。

容器化最初常见于互联网服务商提供的虚拟服务器，如 OpenVZ 等。服务商通过容器化的方式将一台宿主机分割为一系列虚拟机用于出租，这样的收益比起单独出租物理服务器会高一些；现在更常见的应用场景是基于 Docker 的容器化，Docker 将用户程序和对应环境打包为一个容器，以此加快部署。

### 2.4 Docker

Docker 是常见的容器化技术之一，属于上述操作系统级虚拟化的一个比较典型的应用。Docker 目前支持 Windows 和 Linux，不过比较常用的平台还是 Linux。

![](https://upload.wikimedia.org/wikipedia/commons/thumb/0/09/Docker-linux-interfaces.svg/440px-Docker-linux-interfaces.svg.png)

Docker for Linux 利用上述的 cgroup、namespace 实现用户空间隔离与资源分配，使用 NetFilter 组件实现不同的网络 namespace 之间的通信。为了提高安全性，避免容器隔离机制失效，还会使用 SELinux、AppArmor 等访问控制工具严格控制每一个容器的行为。

Docker 隔离根文件系统的方式比较特别：除了使用 chroot 隔离之外，Docker 的文件系统还会使用支持联合挂载的文件系统，如 OverlayFS、ZFS、btrfs 等来实现，并借此实现了容器的版本控制。每一个版本在 Docker 中被称为“层”，对某一层的修改可以被记录下来成为新的“层”。启动容器时通过联合挂载的方式，提供一个合并了所有“层”的视图给容器内的应用程序。

![](https://docs.docker.com/storage/storagedriver/images/container-layers.jpg)

除此之外，Docker 还可以将容器（所有的“层”）打包为映像，并进行快速部署与分发。Docker 还提供 Swarm 和 Compose 两个工具，Swarm 用于管理一组容器，Compose 用于通过脚本来进行自动的容器构建。

### 2.5 版本控制工具 Git

版本控制是指对计算机系统中的文档、程序或其他信息集合的修改的管理。这些修改会由被称为“版本号”的编号进行标记，如最早版本的文件被称为版本 1，进行过第一次修改后的文件被称为版本 2。每一个版本都会有其对应的修改时间以及修改人，且不同的版本可以互相比较、恢复，对特定类型的文件还可以进行合并。

对于一个文件，可能会出现两个人分别进行了不同的修改的情况，这种情况被称为分支。不同的分支可以通过一些方式进行合并。

Git 是一个比较典型的用于进行版本控制的工具，最初是用来协助开发 Linux 内核的。它是一个分布式的版本控制工具，也就是说每一台计算机上都会有整个代码库的一个副本。

Git 的特点有：

* 对分支及合并的完善支持。Git 包含一系列工具用于在版本和分支之间进行导航。
* 支持分布式的开发。每一个开发者都有某一代码库的完整副本。
* 与现有系统和通讯协议的兼容。Git 可以使用 http、ftp、ssh 等协议在不同的设备之间进行通信以交换版本库。
* 对大规模项目的高效支持。
* 对版本的完整性检查。
* 多种合并分支的策略。

### 2.6 Django

Django 是一个 Python 编写的 Web 框架，遵循 MVC（Model - View - Controller）的模式。Django 的主要目标是降低开发网站的复杂性，因此其包含丰富的组件以帮助开发者快速建立网站。

Django 的核心组件包括：

* ORM（对象 - 关系映射）。这是用于将关系型数据库中的数据转换为 Python 中的对象，以便使用面向对象的方式来操作这些数据。
* 模版引擎。用于将数据渲染成 HTML 页面。
* 基于正则表达式匹配的 URL 分发器。

除此之外还有一些其他的帮助用户快速开发的工具：

* 轻量级的 Web 服务器，用于开发与测试。
* Web 表单处理器。
* 缓存模型。
* 中间件支持。
* 国际化支持，包含多语言以及本地化支持。
* 序列化、反序列化工具，用于 Django 数据对象和 JSON / XML 的相互转换。
* 集成的 Python 单元测试工具。
* 用户身份验证、权限管理模块。
* 可视化的管理员界面。
* 安全检查工具，可以防御 CSRF（跨站攻击）、XSS（跨站脚本）、SQL 注入等典型的 Web 攻击策略。

### 2.7 JQuery 与 Bootstrap

我们知道，对于典型的 B/S 架构的应用程序，呈现给用户的是一个在浏览器中显示的 Web 页面。对于其中的一些逻辑需要 Javascript 来进行编写。而不同浏览器提供的 Javascript API 往往有所区别。JQuery 是用于简化在浏览器使用 Javascript 并消除不同浏览器之间差异的一套工具，其特殊设计的语法使得操作浏览器中的元素、创建动画、发送 Ajax 请求等变得简单很多。

JQuery 的核心是一个对 DOM（文档 - 对象模型）的抽象。DOM 是一个用于表现浏览器中元素结构的树形结构，JQuery 简化了操作 DOM 的流程。JQuery 还提供了其他的一些工具，使得开发者可以通过事件来处理用户点击浏览器中元素的操作。同样 JQuery 还提供了对 XMLHttpRequest（Ajax）的封装，降低了开发者使用 Ajax 的复杂性。

Bootstrap 是由 Twitter 推出的基于 JQuery 开发的前端框架，包含一系列元素组件，如表单、按钮、导航组件以及其他常用的 Web 元素，支持响应式布局。Bootstrap 以其方便使用的栅格布局工具和简洁清新的设计风格受到大量 Web 开发者的欢迎。

### 2.8 本章小结

本章将项目中重点采用的技术和方案进行了介绍，首先介绍了 OpenWrt 以及其原始构建工具集，接着分别介绍了本项目实施中使用的一系列支撑技术，包括虚拟化技术、容器技术、版本控制工具以及 Web 框架等。

## 3 需求分析

本章对所开发的自动构建工具的需求进行讨论分析。

### 3.1 可行性分析

开发此自动构建工具的主要目的在于降低部署新构建环境、构建 OpenWrt 系统的复杂性。这对这一构建工具的要求在于：

* 能够将 OpenWrt 原始构建工具的使用门槛尽可能通过图形化界面等方式降低，将更新代码、构建等步骤尽可能自动化完成。
* 能够利用本工具快速部署新的构建环境，进行构建操作。

#### 3.1.1 技术可行性

通过一系列调研，我们发现可以使用 Docker 打包整体构建环境，实现构建环境的快速复制和快速部署；OpenWrt 构建环境采用 Git 进行版本控制，而自动化操作 Git 在业界已有多种成熟方案可以采用。对于用户界面部分，则可以使用常见的 Web 前后端框架来进行开发，给用户提供浏览器中的界面，进一步降低用户使用该自动构建系统的门槛。经过一系列评估，我们认为开发这套系统在技术上有一定的可行性。

#### 3.1.2 经济可行性

构建本系统的主要目标就是通过降低构建过程复杂性提升总体开发效率。产品评估测试人员可以非常快捷的通过该环境获得开发人员提交的最新版本，并选择相关部分进行快速构建和测试，将之前这些步骤所需的一系列复杂操作进行简化以便将更多的精力投入到评估与测试工作中。

该系统运行时仅需一台额外服务器部署该系统，原有的构建用服务器仅需配置 Docker 环境即可接入该系统内进行控制，并不会过多的消耗原有的服务器资源。同时利用 Docker 容器实现构建环境隔离，原有构建服务器可以同时进行多项构建任务而不会导致构建工作互相影响，提升了构建服务器的利用率。

经过考虑，开发并应用该自动构建系统有较高的投入产出比，在经济上有可行性。

#### 3.1.3 操作可行性

该系统目标为解决构建过程过于复杂的问题，设计时便会考虑本系统的易用性。仅需对现有产品评估测试人员进行十分简单的培训即可让这些团队成员快速掌握该系统的使用方案。且该系统不会修改原有构建环境，在该系统无法使用时，产品测试人员仍可以使用旧有构建流程完成构建工作，不会造成严重的影响，因此在操作上有可行性。

### 3.2 功能性需求

本系统应该包括的功能有：

1. 对构建容器的创建、修改、删除操作；
2. 对于每一个构建容器：
    1. 更新容器内的 OpenWrt 核心代码；
    2. 管理和更新容器内的软件包库；
    3. 给用户提供图形化的构建配置界面，让用户以所见即所得的方式配置整个构建流程；
    4. 在容器内完成软件包和系统的构建工作，并将构建结果及系统映像等返回给用户；
    5. 在上述步骤出现错误以至于无法继续时，可以给用户提供必要的信息以帮助用户解决问题。
3. 对于特定的体系结构，可以启动虚拟环境，对构建结果进行测试。

### 3.3 可用性需求

可用性需求是指一个系统能正常对外服务的程度，一般用一定时间内正常运行时间的百分比表示。本系统应达到 99.9% 的可用性。

### 3.4 安全性需求

本系统本身不包含对敏感信息的处理，但是会操作系统中需要特权的一些组件，如虚拟化使用的虚拟机监视器，以及 Docker 服务守护进程等，因此系统需要拥有足够的安全保护措施，防止恶意攻击者通过本系统获取对这些特权组件的访问，进而控制整个系统。

### 3.5 性能需求

对于本系统向各个构建服务器以及其上构建容器发送的构建命令，系统应在 1s 内将构建命令传递到对应 Worker 并使其开始执行任务；构建流程的速度取决于构建服务器本身的性能以及同时构建任务的数量，本构建系统并不直接干预构建流程。

### 3.6 本章小结

本章针对本构建系统的需求，首先从技术、经济和操作三个方面描述了可行性分析的过程，然后针对使用场景分析了功能需求。最后从可用性、安全性、性能三个非功能性的需求描述了对本构建系统期望的特性。

## 4 设计方案

本章详述本自动构建系统的设计方案。设计方案首先包括整体架构，然后是对本系统中涉及到的一系列组成部分进行详细描述，以及为了满足需求分析中出现的需求进行的详细设计。

### 4.1 架构方案

本构建系统的架构方案如下图所示：

```
user -> browser -> ledeforge -> docker-daemon -> local docker registry (pull containers from local registry)
user -> browser -> ledeforge -> docker-daemon -> remote docker repository (build containers by compose)
user -> browser -> ledeforge -> docker-daemon, docker-daemon (manage containers)
user -> browser -> ledeforge -> docker-daemon -> container, container (connect to container for tasks)
user -> browser -> ledeforge -> docker-daemon -> container -> remote git repository (update code by git)
user -> browser -> container -> ttyd (direct access to containers)
```

该架构方案是：用户通过浏览器操作本构建系统；本构建系统连接到对应构建服务器上的 Docker 服务进行容器的构建或者拉取等操作；本构建系统通过 Docker 服务连接到对应容器进行代码更新或者构建操作；对应容器启动时会在容器内启动一个 Worker 负责与本构建系统的通讯，同时这个 worker 会启动一个供用户直接访问的命令行界面，方便用户直接操作构建环境或解决自动构建过程中可能出现的问题。

### 4.2 仓库（Repository） 

仓库在这里指的是 Git 进行版本控制时的代码库。OpenWrt 的代码库使用 Git 进行版本控制，其上运行的第三方软件大多同样使用 Git 进行版本控制，少部分会使用 SVN 等其他版本控制工具。

OpenWrt 的代码库本身包括以下组成部分：

* OpenWrt 原始构建工具 BuildRoot（包括交叉编译工具等）
* OpenWrt 目标集（包含所有 OpenWrt 支持的设备所需的一些配置）
* OpenWrt 基础组件代码库
* OpenWrt 自带的一部分软件包的代码库

可以通过配置代码库中 feeds.conf 的方式来添加第三方软件包的代码库。

对于 OpenWrt 来说，更新基础组件的代码和第三方软件包的代码均需要在仓库中进行

### 4.4 构建 Worker
### 4.5 测试环境
### 4.6 用户界面
#### 4.6.1 Kconfig 界面
#### 4.6.2 xterm 界面
#### 4.6.3 其他界面
### 4.7 本章小结

--- 考虑到 Kconfig 界面需要时间考虑怎么做，多分一段时间 4.27 4.28 4.29

## 5 具体实现
### 5.1 构建环境 Worker
#### 5.1.1 管理 Docker 容器
#### 5.1.2 更新 OpenWrt 代码
#### 5.1.3 管理 OpenWrt 软件源
#### 5.1.4 管理构建流程

--- 5.1 一整天

### 5.2 测试环境 Tester
### 5.3 用户界面 Manager
#### 5.3.1 Kconfig 界面
#### 5.3.2 xterm 界面
#### 5.3.3 普通的控制台回显界面
#### 5.3.4 其他的界面
### 5.4 本章小结

--- 还是 Kconfig 的问题，5.2 5.3 两天

## 6 测试与结果分析
### 6.1 开发环境及相关工具
### 6.2 测试环境与测试工具
### 6.3 测试用例与结果分析
#### 6.3.1 功能测试
#### 6.3.2 可用性测试
#### 6.3.3 安全性测试
#### 6.3.4 性能测试
### 6.4 本章小结
## 7 总结与展望
## 致谢
## 参考文献

--- 5.4 5.5 5.6 三个晚上尽量弄完这些吧

## 10000 字的英文翻译

--- 5.6 5.7 5.8 5.9 5.10 应该足够了，主题看 Kconfig 实现的情况，选择 Docker / Kbuild + Kconfig

# 后续：

* 5.8 - 5.10 公司工作交接 + 英文翻译 + 有时间的话去做查重

* 5.11 / 5.12 回学校，大概要办一些手续之类，舟车劳顿恐怕没时间
* 5.15 之前仍然查重收尾
 