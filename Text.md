# Text

## 摘要

随着宽带技术以及物联网技术的发展，现在家庭中的智能设备越来越多，无线路由器、网络存储等设备愈加频繁的出现在我们的生活当中。很多这样的设备，其操作系统都是基于一套名为 OpenWrt 的基于 Linux 的嵌入式系统定制而来。该系统拥有开放源代码、兼容平台广泛、高度灵活可定制化等特点，受到很多厂商欢迎，但其构建过程较为繁琐，尤其对于产品研发团队内的部分非技术职位人员来说门槛过高，他们构建用于评估、测试等需求用的环境时会有诸多不便。

本文描述一套用于实现自动构建 OpenWrt 环境的工具，其功能包括自动更新、自动构建 OpenWrt 环境，并可通过基于 Web 的图形化界面对定制过程进行定制，以求降低构建评估测试环境时的繁琐程度。在介绍容器、Web 服务、虚拟化和版本控制工具等相关技术的基础上，探讨如何利用这些技术达到上述目的，并给出综合这些技术后的系统整体解决方案。

关键词：自动构建、容器、Web 服务

## 1 绪论

### 1.1 研究背景和意义

随着宽带技术以及物联网技术的发展，现在家庭中的智能设备越来越多，不仅是很多电视、冰箱之类的白色家电都更多的加入了与网络连接的功能，更多样的工具比如扫地机器人、智能传感器等智能家居设备也越来越频繁的出现在我们的生活中。

很多这样的设备，其操作系统都是从一套名为 OpenWrt 的，基于 Linux 的嵌入式系统定制而来。该系统由包括 Linux 内核、opkg 包管理器、LuCI 管理界面、Busybox 等系统软件、以及一系列应用软件组合而成，兼容包括 Atheros、Qualcomm、MediaTek、BroadCom 等在内的绝大多数常见 SoC。其功能十分强大，且可以根据需求自由裁剪系统模块或增加特定功能；源代码完全开放，授权方式灵活，很多新的智能产品如小米、TP-Link、斐讯、水星等厂商的家庭用无线路由器，使用的都是基于 OpenWrt 深度定制并添加部分私有功能 / 驱动程序的操作系统。

OpenWrt 以上述一系列特点受到很多厂商青睐，使用 OpenWrt 开发智能设备使用的操作系统可以极大加快开发进度。但是产品研发的过程中涉及到一系列不同的参与者，对于部分不了解技术的团队成员来说需要降低他们实际参与开发活动的难度。

本文侧重于解决在基于 OpenWrt 进行项目开发时的一大难点：整体系统的构建。对于一个典型的 OpenWrt 项目，一般由 OpenWrt 原生组件（Linux 内核、LuCI 管理界面等）以及厂商编写的第三方软件（如智能流控、手机控制等）组合而成。测试人员进行测试时需要将需测试的组件或系统模块等的代码更新，然后再构建整个系统，构建完成之后将系统通过 TFTP 等方式烧写至测试用的设备中再进行后续的测试。而其中更新代码、构建整体系统这部分工作较为复杂，对于产品、测试人员来说不够友好。此外，构建环境本身的搭建也同样十分复杂，且构建环境对不同的目标平台无法实现隔离，非常不易于管理和维护。

### 1.2 项目研究目标

本文针对 1.1 节中提出的一系列问题，设计了一套构建工具。这套工具可以让用户以图形化的方式完成整个构建流程，使得用户可以非常轻松的完成上述组件更新以及系统构建的工作，提升工作效率；针对构建环境的运维问题，利用容器等技术对不同的构建环境进行隔离，区分管理。两者结合，使得项目开发综合效率得到显著提升。

### 1.3 本文工作和论文结构

本文主要介绍了这套自动构建系统的开发背景，以及设计和实现的工作，重点探讨了实际设计上的一些问题。

第一章讨论了本系统实现的背景以及期望达到的目标。

第二章介绍了本套系统设计上使用的一系列相关技术，包括 OpenWrt 嵌入式系统、OpenWrt 原构建系统的基础 Kbuild / Kconfig、管理构建环境时使用的 Docker 容器、搭建测试环境时使用的虚拟化相关技术、管理 OpenWrt 代码库以及厂商自有软件仓库使用的版本控制工具 Git，以及这套自动构建工具使用的 Web 后端框架 Django 以及前端框架 Bootstrap。

第三章介绍了本套系统的需求分析，包括可行性、功能性、可用性、安全性、性能等需求。

第四章介绍了整套系统的总体设计方案，包括整套系统的总体架构设计、对 OpenWrt 构建过程中一系列实体的抽象，以及完成构建工作所需的所有步骤。

第五章描述了第四章中所述所有设计的具体实现。

第六章首先介绍了开发过程中使用的工具以及环境，然后提出一些测试用例并展示了测试结果，对结果进行分析和说明。

第七章总结了本系统的功能点，介绍了已经完成的工作并列出了其中不足之处，并对下一步的工作进行介绍。

## 2 相关理论与技术

本章对论文研究中设计的相关理论和技术进行阐述，这些技术包括 OpenWrt 自身、OpenWrt 的原始构建工具集、基于 Docker 的容器技术、虚拟化相关的技术、用于版本控制的 Git、用于呈现用户界面的 Django 和 Bootstrap 框架等。

### 2.1 OpenWrt / LEDE

OpenWrt 是一款针对嵌入式系统设计的基于 Linux 的开源项目，主要被设计用于路由器等网络设备。其主要包括的组件有 Linux 内核、uClibC / musl C 标准库、BusyBox 工具集、opkg 包管理器、LuCI 界面等。OpenWrt 的所有基础组件都针对嵌入式的应用环境进行裁剪以及优化，因此可以运行在很多只有 32MB 内存、4MB Flash 空间的家用路由器上。

OpenWrt 支持超过 50 种不同的硬件体系结构，包括 MIPS、ARM、x86/64 等。市面上最常见的家用路由器一般采用来自 QualComm（Atheros）、BroadCom、MediaTek（RaLink）等公司的基于 MIPS 指令集的方案，这些公司的部分产品也有基于 ARM 指令集的。x86/64 方案则常见于网吧、中小型企业的路由设备中。

OpenWrt 包含强大的路由功能支持：硬件方面，除去上面提到的硬件体系结构的广泛支持外，也支持绝大多数厂商的有线、无线局域网硬件方案，以及常见的 LTE 移动网络方案；支持包括以太网、DSL、ISDN 等的一系列规范；支持 IPv4 和 IPv6；支持动态路由、VPN、QoS、防火墙、NAT、负载均衡、链路叠加等常见路由功能；支持包括 Mesh、WDS 等特性的无线网络功能。

除此之外，OpenWrt 还能通过 opkg 添加其他被 Linux 操作系统直接支持的硬件的支持；包括但不限于打印机、监控摄像头、声卡、外置存储设备等，并可以安装 Samba、PulseAudio、p910nd 等 Linux 上使用的应用软件。这使得 OpenWrt 除了作为路由器使用的操作系统之外，也非常适合其他的嵌入式设备，如网络存储、打印服务器、智能监控摄像头、智能音响等。

OpenWrt 与其他常见的针对家用路由器设计的嵌入式操作系统，如 DD-WRT 等的区别主要在于以下两点：

* OpenWrt 包含一个可以写入的根文件系统。OpenWrt 使用只读和压缩的 squashfs 提供根文件系统，并利用 overlayfs，采取 CoW（写时复制）的方式在只读的根文件系统上叠加一个 F2FS 文件系统。
* OpenWrt 利用包管理器 opkg 管理软件包。OpenWrt 官方提供的软件源中包含超过 3500 个不同的软件包，这使用户可以自由安装卸载软件，对自己的设备进行定制。

LEDE 是 Linux Embedded Development Environment 的缩写。它是 OpenWrt 的一个分支，采取比 OpenWrt 更加激进的开发流程。2016 年 5 月 LEDE 项目从 OpenWrt 拆分出来进行独立开发，之后 OpenWrt 几乎停止了迭代。月一年版之后的 2018 年 1 月，LEDE 与 OpenWrt 项目宣布合并，原 OpenWrt 项目被归档不再开发，LEDE 更名为 OpenWrt，取代原来的 OpenWrt。

### 2.2 OpenWrt BuildRoot、Kbuild 与 Kconfig

一般来说嵌入式设备会使用与其构建环境不同的体系结构，比如 OpenWrt 一般在 x86/64 设备上进行构建，构建后运行在 MIPS / ARM 设备上，这种构建方式被称为交叉编译。OpenWrt 自身的开发环境与构建系统统称为 OpenWrt BuildRoot，这套系统解决了 OpenWrt 构建过程中的一系列问题，如交叉编译所需工具链的集成、应用软件的交叉编译、CMake 等工具的集成、对不同设备映像的封装等。

OpenWrt 构建工具使用 Kconfig 配置构建过程中的可选项，如目标平台和软件包等。Kbuild 是 Linux 内核使用的构建工具集，Kbuild 在 GNU Make 的基础上对其 Makefile 进行了功能扩充，使得内核编译过程可以更加高效的完成；Kconfig 则是 Kbuild 使用的配置文件，用于定制 Kbuild 使用的一系列选项。

### 2.3 虚拟化

虚拟化技术是一种资源管理的技术，指将计算机中的资源进行抽象后拆分并重新组合为一个或多个资源组，使用户更好的使用这些计算资源的技术。

虚拟化技术覆盖的层次非常广泛，一般分为五个等级：

![](https://upload.wikimedia.org/wikipedia/commons/3/3a/VT5levels.JPG)

我们这里介绍其中两个等级。

#### 2.3.1 硬件虚拟化

硬件虚拟化指的就是将物理计算机中的资源进行拆分并重新组合为一些虚拟的计算机，这些虚拟计算机拥有与真实计算机类似的功能，并共享物理计算机所有的资源。这里的物理计算机称为宿主机（Host），其上运行的虚拟计算机称为客户机（Guest）。宿主机上运行的用于拆分、重组计算资源的软件被称为虚拟机管理器（Hypervisor）。

硬件虚拟化包括以下两种类别：

1. 全虚拟化（Full Virtualization）：用软件的方式完全模拟一个运行环境。这种方式运行的 Hypervisor 会提供完整的硬件特征，包括完整的体系结构、IO 操作、中断与内存管理等。在这样的环境中运行的代码不需进行任何修改。
2. 半虚拟化（Paravirtualization）：利用宿主机提供的 API 接口模拟运行环境，其上运行的代码需要针对宿主机平台特别定制，通常效率比全虚拟化要高，但是虚拟机的体系结构只能与宿主机保持一致。

很多现代 CPU 都会提供特殊的指令以便加速虚拟化过程，比如 Intel 的 VT-x 和 AMD 的 AMD-V；新一些的 CPU 还会提供对外部设备进行虚拟化的功能，比如 Intel 的 VT-d，利用这些功能可以使虚拟机直接控制宿主机上的部分硬件设备（如显卡、存储控制器、网络控制器等），极大提升硬件虚拟化的效率。现代操作系统均提供利用这些特性进行半虚拟化的支持，如 Windows 的 Hyper-V、Linux 的 KVM 等。一些第三方服务商，如 VMWare，提供的产品也支持利用这些虚拟化特性提高效率。

#### 2.3.2 操作系统级虚拟化

操作系统级虚拟化一般也被称为容器化，是指在操作系统的层面对不同的用户空间进行隔离的技术。被分离的用户空间一般被称为容器。容器中运行的代码只能操作对应容器被分配的资源配额，并且不同的容器之间互相完全不可见。

操作系统级虚拟化与硬件虚拟化相比，其优势在于可以减少在虚拟机上启动操作系统带来的资源消耗。容器内的应用程序直接使用宿主操作系统提供的系统调用，而不需要在虚拟机中启动新的操作系统，并由虚拟机上的操作系统提供用于与虚拟化的硬件进行交互的系统调用，如此可以极大降低启动时间和资源占用。而这也同样导致容器内的操作系统必须与宿主机保持一致，不能像硬件虚拟化那样，在 Linux 宿主机上运行 Windows 虚拟机。

在传统的类 Unix 操作系统中，通过 chroot 的方式可以实现对根文件系统的隔离。而在更新一些版本的 Linux 中，通过 cgroup（Control Group，控制组）和 namespace（命名空间）的方式可以实现对 CPU 核心、内存空间、网络、用户、进程等绝大多数系统资源的隔离。

容器化最初常见于互联网服务商提供的虚拟服务器，如 OpenVZ 等。服务商通过容器化的方式将一台宿主机分割为一系列虚拟机用于出租，这样的收益比起单独出租物理服务器会高一些；现在更常见的应用场景是基于 Docker 的容器化，Docker 将用户程序和对应环境打包为一个容器，以此加快部署。

### 2.4 Docker

Docker 是常见的容器化技术之一，属于上述操作系统级虚拟化的一个比较典型的应用。Docker 目前支持 Windows 和 Linux，不过比较常用的平台还是 Linux。

![](https://upload.wikimedia.org/wikipedia/commons/thumb/0/09/Docker-linux-interfaces.svg/440px-Docker-linux-interfaces.svg.png)

Docker for Linux 利用上述的 cgroup、namespace 实现用户空间隔离与资源分配。除此之外，Docker 还可以将容器打包为映像，并进行快速部署与分发。Docker 还提供 Swarm 和 Compose 两个工具，Swarm 用于管理一组容器，Compose 用于通过脚本来进行自动的容器构建。

### 2.5 版本控制工具 Git

版本控制是指对计算机系统中的文档、程序或其他信息集合的修改的管理。这些修改会由被称为“版本号”的编号进行标记，如最早版本的文件被称为版本 1，进行过第一次修改后的文件被称为版本 2。每一个版本都会有其对应的修改时间以及修改人，且不同的版本可以互相比较、恢复，对特定类型的文件还可以进行合并。

Git 是一个比较典型的用于进行版本控制的工具，最初是用来协助开发 Linux 内核的。

### 2.6 Django 与 Bootstrap

--- 选一个双休日写完这些，4.29 4.30

## 3 需求分析
### 3.1 可行性分析
#### 3.1.1 技术可行性
#### 3.1.2 经济可行性
#### 3.1.3 操作可行性
### 3.2 功能性需求
### 3.3 可用性需求
### 3.4 安全性需求
### 3.5 性能需求
### 3.6 本章小结

--- 两个晚上写完这些，4.24 4.25

## 4 设计方案
### 4.1 架构方案
### 4.2 仓库（Repository）
#### 4.2.1 普通仓库
#### 4.2.2 容器化管理的仓库
### 4.3 工作空间（Workspace）
### 4.4 构建 Worker
#### 4.4.1 普通的 Worker
#### 4.4.2 容器中的 Worker

--- 考虑到这两个应该都实现完了，4.26 一天晚上应该足够，不够的话跟下面的共享一天

### 4.5 测试环境
### 4.6 用户界面
#### 4.6.1 Kconfig 界面
#### 4.6.2 xterm 界面
#### 4.6.3 其他界面
### 4.7 本章小结

--- 考虑到 Kconfig 界面需要时间考虑怎么做，多分一段时间 4.27 4.28 4.29

## 5 具体实现
### 5.1 构建环境 Worker
#### 5.1.1 管理 Docker 容器
#### 5.1.2 更新 OpenWrt 代码
#### 5.1.3 管理 OpenWrt 软件源
#### 5.1.4 管理构建流程

--- 5.1 一整天

### 5.2 测试环境 Tester
### 5.3 用户界面 Manager
#### 5.3.1 Kconfig 界面
#### 5.3.2 xterm 界面
#### 5.3.3 普通的控制台回显界面
#### 5.3.4 其他的界面
### 5.4 本章小结

--- 还是 Kconfig 的问题，5.2 5.3 两天

## 6 测试与结果分析
### 6.1 开发环境及相关工具
### 6.2 测试环境与测试工具
### 6.3 测试用例与结果分析
#### 6.3.1 功能测试
#### 6.3.2 可用性测试
#### 6.3.3 安全性测试
#### 6.3.4 性能测试
### 6.4 本章小结
## 7 总结与展望
## 致谢
## 参考文献

--- 5.4 5.5 5.6 三个晚上尽量弄完这些吧

## 10000 字的英文翻译

--- 5.6 5.7 5.8 5.9 5.10 应该足够了，主题看 Kconfig 实现的情况，选择 Docker / Kbuild + Kconfig

# 后续：

* 5.8 - 5.10 公司工作交接 + 英文翻译 + 有时间的话去做查重

* 5.11 / 5.12 回学校，大概要办一些手续之类，舟车劳顿恐怕没时间
* 5.15 之前仍然查重收尾
 